#include <stdio.h>
#include <stdlib.h>

//百度2015年系统工程师笔试题：
//请简述大端字节序和小端字节序的概念，设计一个小程序来判断当前机器的字节序
//大端字节序也称：大端（存储）模式，是指数据的低位保存在内存的高地址中，而数据的高位保存在内存的低地址中
//大端字节序也称：小端（存储）模式，是指数据的低位保存在内存的低地址中，而数据的高位保存在内存的高地址中
int check_sys()
{
    int a=1;
    return *(char*)&a;
}

int main()
{
    int ret=check_sys();
    if(ret==1)
        printf("小端\n");
    else
        printf("大端\n");

    char a=-1;
    //10000000 00000000 00000000 00000001
    //11111111 11111111 11111111 11111110
    //11111111 11111111 11111111 11111111
    //char类型只有一个字节，所以存储的是11111111
    //char要存储整型，发生整型提升：
    //因为是是负数，有符号位，所以前面补1，又补成：
    //11111111 11111111 11111111 11111111
    //此时是补码，再减1取反，得到原码：
    //10000000 00000000 00000000 00000001
    //所以得到的a是负1
    signed char b=-1;
    //signed char有符号位跟char相同，打印的是-1
    unsigned char c=-1;
    //无符号位，在11111111前面补0，得到：
    //00000000 00000000 00000000 11111111
    //所以打印的是255
    printf("a=%d b=%d c=%d\n",a,b,c);//-1 -1 255

    char d=-128;
    //10000000 00000000 00000000 10000000
    //char d得到的是10000000
    //整型提升得到
    //11111111 11111111 11111111 10000000
    //因为打印的是无符号十进制位，所以原反补码相同
    //所以直接就打印出来：
    //11111111 11111111 11111111 10000000
    //=4294967168
    printf("%u\n",d);
    //其实如果char d=128,打印的也还是4294967168
    //因为存储的补码还是10000000
    //&d有符号十进制位
    //&u无符号十进制位
    return 0;
}

//char在内存中补码
//00000000  -> 1
//00000001  -> 2
//00000010  -> 3
// ......
//01111111  -> 127
//10000000  -> -128
//10000001  -> -127
// ......
//11111101  -> -3
//11111110  -> -2
//11111111  -> -1

//由此可见，有符号位的char类型的取值范围是-128~127
//其中10000000直接规定成-128
//假设我们有9个比特位
//补码：   110000000
//减1得到：101111111
//原码：   110000000
//所以，这样看也是-128

//无符号位char类型取值就是0~255了
