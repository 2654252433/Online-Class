#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <error.h>

//为什么存在动态内存分配
//我们已经掌握的内存开辟方式有
//int val=20;//在栈空间上开辟四个字节
//char arr[10] = {0};//在栈空间上开辟10个字节的连续空间
//但是上述的开辟空间的方式有两个特点
//1.空间开辟大小是固定的
//2.数组在申明的时候，必须指定数组的长度，它所需要的内存在编译时分配.
//但是对于空间的需求，不仅仅是上述的情况。有时候我们需要的空间大小在程序运行的时候才能知道，
//那数组的编译时开辟空间的方式就不能满足了。这时候就只能试试动态内存开辟了。

//动态内存函数的介绍
//malloc和free
//C语言提供了一个动态内存开辟的函数：
//void* malloc(size_t size);
//需引用头文件#include <stdlib.h>
//这个函数向内存申请一块连续可用的空间，并返回指向这块空间的指针。
//1.如果开辟成功，则返回一个指向开辟好空间的指针。
//2.如果开辟失败，则返回一个NULL指针，因此malloc的返回值一定要做检查
//3.返回值的类型是void*，所以malloc函数并不知道开辟空间的类型，具体在使用的时候使用者自己来决定。
//4.如果参数size为0，malloc的行为是标准未定义的，取决于编译器。

//C语言提供了另外一个函数free，专门是用来做动态内存的释放和回收的，函数原型如下:
//void free (void*ptr);
//需引用头文件#include <stdlib.h>
//free函数用来释放动态开辟的内存
//如果参数ptr指向的空间不是动态开辟的，那free函数的行为是未定义的
//如果参数ptr是NULL指针，则函数什么事都不做。

int main()
{
    //向内存申请10个整型的空间
    int*p=(int*)malloc(10*sizeof(int));
    if(p==NULL)
    {
        //打印错误原因的一个方式
        printf("%s\n",strerror(errno));
    }
    else
    {
        //正常开辟使用
        int i=0;
        for(i=0;i<10;i++)
        {
            *(p+i)=i;
        }
        for(i=0;i<10;i++)
        {
            printf("%d ",*(p+i));
        }
    }
    //当动态申请的空间不再使用的时候
    //就应该还给操作系统
    free(p);
    p=NULL;
    return 0;
}
