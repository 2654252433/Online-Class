#include <stdio.h>
#include <stdlib.h>

struct Test
{
  int num;
  char*pcname;
  short sdate;
  char cha[2];
  short sba[4];
}*p;

int main()
{
    int a[3][4]={0};
    printf("%d\n",sizeof(a));//48 计算的是数组总大小，也就是3*4*4=48
    printf("%d\n",sizeof(a[0][0]));//4 a[0][0]是数组第一个元素，所以是4个字节
    printf("%d\n",sizeof(a[0]));//16 此处a[0]相当于第一行作为一维数组的数组名，而因为a[0]是数组名单独放进sizeof()内的，所以计算的是第一行的大小
    printf("%d\n",sizeof(a[0]+1));//4/8 a[0]是第一行数组名，而a[0]+1是数组第一行第二个元素地址，并不是指第二行地址，所以是4/8字节
    printf("%d\n",sizeof(*(a[0]+1)));//4 a[0]+1是第一行第二个元素地址，解引用则是第一行第二个元素。所以是4个字节
    printf("%d\n",sizeof(a+1));//4/8 a不是单独放在sizeof内，所以数组名表示第一行地址，a+1则表示第二行地址，是地址就是4/8
    printf("%d\n",sizeof(*(a+1)));//16 解引用第二行地址，也就是计算第二行的大小，所以是16
    printf("%d\n",sizeof(&a[0]+1));//4/8 &a[0]表示取第一行的地址，+1则表示取第二行的地址，是地址就是4/8
    printf("%d\n",sizeof(*(&a[0]+1)));//16 解引用第二行地址，也就是第二行大小，所以是16
    printf("%d\n",sizeof(*a));//16 a表示第一行，*a则是解引用第一行，所以计算的是第一行的大小，是16字节
    printf("%d\n",sizeof(a[3]));//16 a[3]虽然看起来是第四行，可实际上sizeof不会访问超出的部分，只会访问跟sizeof(a[0])一样的类型，所以计算的还是一行的大小，是16

    //指针笔试真题：
    //第一题
    int b[5]={1,2,3,4,5};
    int*ptr=(int*)(&b+1);
    printf("%d,%d\n",*(b+1),*(ptr-1));//2,5

    //第二题
    //假设p的值为0x100000，如下表达式的值分别为多少？
    //已知，结构体Test类型的变量大小是20个字节
    p=(struct Test*)0x100000;
    printf("%p\n",p+0x1);//100020 因为p是20，0x1是0x100000，所以加起来是100020
    printf("%p\n",(unsigned long)p+0x1);//100001 此处将p转换为无符号长整型，也就是十六进制100000转换为十进制1048576，在1048576上加1，等于1048577，然后又转换回来十六进制，所以只不过是在100000上加了1而已，也就是100001
    printf("%p\n",(unsigned int*)p+0x1);//100004 将p转换为int类型再加1，而int类型加1等于加了4个字节，所以是在100000基础上加了4，也就是100004
    return 0;
}
