#include <stdio.h>
#include <stdlib.h>

//1、结构体：
//定义：结构是一些值的集合，这些值称为成员变量。结构的每个成员可以是不同类型的变量
//结构的声明：
/* struct tag
   {
     member-list;
   }variable-list;
*/

//声明一个学生类型，想通过学生类型来创建学生变量(对象)
//描述学生的属性：名字-电话-性别-年龄
struct Stu
{
    char name[20];//名字
    char tele[12];//电话
    char sex[10];//性别
    int age;//年龄
};

//匿名结构体类型：
struct//标签可以省略
{
    int a;
    char b;
}x;//但是变量列表不能省略

//匿名结构体指针：
struct
{
    int a;
    char b;
}*pa;


//2、结构体自引用：
//后面讲数据结构的链表与这相似
struct node
{
    int data;
    struct node*next;
};


//3、结构体内存对齐:
//这也是一个特别热门的考点
//考点如何计算？结构体对齐规则：
//1、第一个成员在与结构体变量偏移量为0的地址处。
//2、其他变量成员要对齐到某个数字(对齐数)的整数倍的地址处
//对齐数=编译器默认的一个对齐数与该成员大小的较小值
//VS编译器默认对齐数为8，gcc编译器没有默认对齐数(官方说的，但是网上有人说是4)
//3、结构体总大小为最大对齐数(每个成员变量都有一个对齐数)的整数倍
//4、如果嵌套了结构体的情况，嵌套的结构体对齐到自己的最大对齐数的整数倍处，
//结构体的整体大小就是所有最大对齐数(含嵌套结构体的对齐数)的整数倍。

//为什么存在内存对齐？
//大部分参考资料都是这样说的：
//1.平台原因(移植原因)不是所有的硬件平台都能访问任意地址上的任意数据的；
//  某些硬件平台只能在某些地址处取某些特定类型的数据，否则抛出硬件异常。
//2性能原因:数据结构(尤其是栈)应该尽可能地在自然边界上对齐。
//  原因在于，为了访问未对齐的内存，处理器需要作两次内存访问;而对齐的内存访问仅需要一次访问。
//总体来说:
//结构体的内存对齐是拿空间来换取时间的做法

//那在设计结构体的时候，我们既要满足对齐，又要节省空间，如何做到：
//让占用空间小的成员尽量集中在一起。

//修改默认对齐数：
//#pragma这个预处理指令，可以改变我们的默认对齐数
//例如：
/*
#include <stdio.h>
#pragma pack(8)//设置默认对齐数为8
struct s1
{
    char c1;
    int i;
    char c2;
};
#pragma pack()//取消设置的默认对齐数，还原为默认
*/

//offsetof函数：计算结构体偏移量
//size_t offsetof(struct Name, member Name);
//引用头文件#include <stddef.h>
//例如：
/*
#include <stddef.h>

struct s
{
   char c;
   int a;
   double b;
};

int main()
{
   printf("%d\n",offsetof(struct s,c));
   printf("%d\n",offsetof(struct s,a));
   printf("%d\n",offsetof(struct s,b));
}
*/

//百度笔试题：
//写一个宏，计算结构体中某变量相对于首地址的偏移，并给出说明
//考察：offsetof宏的实现
//注：这里还没学宏，等后面学了宏再实现

//4、结构体传参
//函数传参的时候，参数是需要压栈，会有时间和空间上的系统开销
//如果传递一个结构体对象的时候，结构体过大，参数压栈的系统开销比较大，所以会导致性能的下降
//结论：结构体传参的时候，要传结构体的地址
/*
void print(struct Stu*ps)
{
   printf("%s %s %s %d\n",ps->name,ps->tele,ps->sex,ps->age);
}

int main()
{
   struct Stu s={0};
   print(&s);
}
*/

//5、结构体实现位段
//什么是位段？
//位段的声明和结构是类似的，有两个不同
//1.位段的成员必须是int unsigned int成signed int。
//2.位段的成员名后边有一个冒号和一个数字
//例如：
/*struct A
{
   int a:2;//指a只需要占2个比特位
   int b:5;//b只需要占5个比特位
   int c:10;//c只需要占10个比特位
   int d:30;//d只需要占30个比特位
}
*/
//A就是一个位段类型
//那位段A的大小是多少呢？
//printf("%d\n",sizeof(struct A));

//位段中的位是指二进制位

//位段的内存分配
//1.位段的成员可以是int unsigned int signed int或者是char(属于整形家族)类型
//2.位段的空间上是按照需要以4个字节(int)或者1个字节(char)的方式来开辟的
//3.位段涉及很多不确定因素，位段是不跨平台的，注重可移植的程序应该避免使用位段

//位段的跨平台问题
//1.int位段被当成有符号数还是无符号数是不确定的。
//2.位段中最大位的数目不能确定。(16位机器最大16，32位机器最大32写成27,在16位机器会出问题。
//3.位段中的成员在内存中从左向右分配，还是从右向左分配标准尚未定义
//4.当一个结构包含两个位段，第二个位段成员比较大，无法容纳于第一个位段剩余的位时，舍弃剩余的位还是利用，这是不确定的。

//总结:
//跟结构相比，位段可以达到同样的效果，但是可以很好的节省空间，但是有跨平台的问题存在

//位段的应用：
//微信图片

int main()
{
    //结构体初始化
    struct Stu a={"张三","1008611","男生",20};
    printf("%s %s %s %d\n",a.name,a.tele,a.sex,a.age);

    return 0;
}
