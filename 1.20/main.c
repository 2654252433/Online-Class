#include <stdio.h>
#include <stdlib.h>

void test1(int arr[])
{
    printf("%d\n",sizeof(arr));
}

void test2(char ch[])
{
    printf("%d\n",sizeof(ch));
}

struct stu
{
    char name[20];
    int age;
    char id[20];
};

int main()
{
    int a=0;
    //按二进制位取反
    //原码-->补码-->(按位取反后的)补码-->原码
    //00000000 00000000 00000000 00000000 注意存储的是0的补码，只不过正数的原、反、补码相同
    //11111111 11111111 11111111 11111111 按位取反后存储的是补码
    //11111111 11111111 11111111 11111110 按位取反后的反码
    //10000000 00000000 00000000 00000001 这就是原码，打印出来的也是原码
    printf("%d\n",~a);//-1

    int b=11;
    //00000000 00000000 00000000 00001011
    //此处想将11的倒数第三位0变成1，即1011变成1111
    //只需将对应的0或上一个1即可，因为0|1=1
    b=b|(1<<2);//将1左移两位，此时的1对应着11的0，再或上即可改变
    printf("%d\n",b);

    int arr[10]={0};
    char ch[10]={0};
    printf("%d\n",sizeof(arr));
    printf("%d\n",sizeof(ch));
    test1(arr);
    test2(ch);

    //360的一道笔试题:
    int i=0,c=0,d=2,e=3,f=4;
    i=c++&&++d&&f++;
    //只要&&左边是0，那后面的就都不用算了
    //i=c++||++d||f++;
    //只要||左边是1，那后面的同样也不用算
    printf("c=%d\nd=%d\ne=%d\nf=%d\n",c,d,e,f);

    //条件操作符(三目操作符)：
    //exp1?exp2:exp3  如果exp1表达式为真，则输出exp2表达式的结果
    //如果exp1表达式为假，则输出exp3表达式的结果
    int g=5,h=6;
    int max=0;
/*  if(g>h)
        max=g;
    else
        max=h;  可写为下面这种形式: */
    max=(g>h?g:h);
    printf("%d\n",max);

    //逗号表达式，就是用逗号隔开的多个表达式
    //从左向右依次执行，整个表达式的结果是最后一个表达式的结果
    int j=3,k=5;
    int l=(j>k,j=k+1,j,k=j-2);
    printf("%d\n",l);

    //使用struct stu结构体类型创建一个学生对象s1,并初始化
    struct stu s1={"帅哥",20,"20204073127"};
    struct stu*ps=&s1;//取地址
    printf("%s\n",(*ps).name);//用解引用地址来打印
    printf("%s\n",ps->name);//->结构体指针->成员
    printf("%s\n",s1.name);
    printf("%d\n",s1.age);
    printf("%s\n",s1.id);
    //结构体.成员名

    //隐式类型转换：
    //C的整型算术运算总是至少以缺省整型类型的精度来进行的。
    //为了获得这个精度，表达式中的字符和短整型操作数在使用之前被转换为普通整型，这种转换称为整型提升
    //整型提升是按照变量的数据类型的符号位来提升的
    //long double
    //double
    //float
    //unsigned long int
    //long int
    //unsigned int
    //int
    //如果某个操作数的类型排名较低，则需要转换为另一个操作数的类型后执行运算
    char m=3;
    //char类型只占1个字节，也就是8个比特位，而整型却占4个字节，所以会先把char类型提升为32个比特位再进行运算
    //00000000 00000000 00000000 00000011
    char n=127;
    //00000000 00000000 00000000 01111111
    char o=m+n;
    //00000000 00000000 00000000 10000010
    //补高位符号位
    //11111111 11111111 11111111 10000010 --补码
    //11111111 11111111 11111111 10000001 --反码
    //10000000 00000000 00000000 01111110 --原码
    printf("%d\n",o);//-126

    char p=1;
    //%u是无符号运算
    printf("%u\n",sizeof(p));
    printf("%u\n",sizeof(+p));//+是算术运算，所以得整型提升为4个字节
    printf("%u\n",sizeof(!p));//!是逻辑运算,不用整型提升
    return 0;
}
